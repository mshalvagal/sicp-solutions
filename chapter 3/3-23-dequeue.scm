#lang sicp
(define (make-dequeue)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty-dequeue?)
      (and (null? front-ptr)
           (null? rear-ptr)))
    (define (front-dequeue)
      (if (empty-dequeue?)
          (error "FRONT called with an empty dequeue")
          (car (car front-ptr))))
    (define (rear-dequeue)
      (if (empty-dequeue?)
          (error "REAR called with an empty dequeue")
          (car (car rear-ptr))))
    (define (front-insert-dequeue! item)
      (let ((new-front (list (list item))))
        (cond ((empty-dequeue?)
               (set! front-ptr new-front)
               (set! rear-ptr new-front))
              (else
               (set-cdr! new-front front-ptr)
               (set-cdr! (car front-ptr) new-front)
               (set! front-ptr new-front)))))
    (define (rear-insert-dequeue! item)
      (let ((new-rear (list (list item))))
        (cond ((empty-dequeue?)
               (set! front-ptr new-rear)
               (set! rear-ptr new-rear))
              (else
               (set-cdr! rear-ptr new-rear)
               (set-cdr! (car new-rear) rear-ptr)
               (set! rear-ptr new-rear)))))
    (define (front-delete-dequeue!)
      (cond ((empty-dequeue?)
             (error "FRONT-DELETE! called with an empty dequeue"))
            (else
             (set! front-ptr (cdr front-ptr))
             (set-cdr! (car front-ptr) '()))))
    (define (rear-delete-dequeue!)
      (cond ((empty-dequeue?)
             (error "REAR-DELETE! called with an empty dequeue"))
            (else
             (set! rear-ptr (cdr (car rear-ptr)))
             (set-cdr! rear-ptr '()))))
    (define (print-dequeue)
      (define (iter lis)
        (if (null? lis)
            '()
            (cons (car (car lis))
                  (iter (cdr lis)))))
      (display (iter front-ptr))
      (newline))
    (define (dispatch m)
      (cond ((eq? m 'empty-dequeue?) (empty-dequeue?))
            ((eq? m 'front-dequeue) (front-dequeue))
            ((eq? m 'rear-dequeue) (rear-dequeue))
            ((eq? m 'front-insert-dequeue!) front-insert-dequeue!)
            ((eq? m 'front-delete-dequeue!) (front-delete-dequeue!))
            ((eq? m 'rear-insert-dequeue!) rear-insert-dequeue!)
            ((eq? m 'rear-delete-dequeue!) (rear-delete-dequeue!))
            ((eq? m 'print-dequeue) (print-dequeue))))
    dispatch))

(define (empty-dequeue? dequeue) (dequeue 'empty-dequeue?))
(define (front-dequeue dequeue) (dequeue 'front-dequeue))
(define (rear-dequeue dequeue) (dequeue 'rear-dequeue))
(define (front-insert-dequeue! dequeue item) ((dequeue 'front-insert-dequeue!) item))
(define (front-delete-dequeue! dequeue) (dequeue 'front-delete-dequeue!))
(define (rear-insert-dequeue! dequeue item) ((dequeue 'rear-insert-dequeue!) item))
(define (rear-delete-dequeue! dequeue) (dequeue 'rear-delete-dequeue!))
(define (print-dequeue dequeue) (dequeue 'print-dequeue))



(define dq1 (make-dequeue))
(front-insert-dequeue! dq1 'a)
(print-dequeue dq1)
(rear-insert-dequeue! dq1 'b)
(print-dequeue dq1)
(rear-insert-dequeue! dq1 'c)
(print-dequeue dq1)
(front-delete-dequeue! dq1)
(print-dequeue dq1)
(rear-delete-dequeue! dq1)
(print-dequeue dq1)


