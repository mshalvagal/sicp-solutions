#lang sicp
;;Table operations
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation - TABLE" m))))
    dispatch))
(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
(define (put-coercion source-type target-type proc)
  (put 'coercion (list source-type target-type) proc))
(define (get-coercion source-type target-type)
  (get 'coercion (list source-type target-type)))


;;helper functions
(define (raise-loop arg target-type)
  (let ((raised (raise arg)))
    (if (eq? (type-tag raised) target-type)
        raised
        (raise-loop raised target-type))))

(define (drop arg)
  (let* ((og-type (type-tag arg))
         (dropped (project arg))
         (drop-type (type-tag dropped))
         (re-raised (raise dropped)))
    (if (and (not (eq? og-type drop-type)) (equ? re-raised arg))
         (drop dropped)
        arg)))


(define (raise-args target-type remaining-args result)
  (if (null? remaining-args)
      result
      (let* ((arg (car remaining-args))
             (type (type-tag arg)))
        (if (eq? type target-type)
            (raise-args target-type
                        (cdr remaining-args)
                        (append result (list arg)))
            (raise-args target-type
                        (cdr remaining-args)
                        (append result (list (raise-loop arg target-type))))))))

(define (apply-generic op . args)
  (define (search-and-apply-op)
    (let* ((type-tags (map type-tag args))
           (proc (get op type-tags)))
     (if proc
         (apply proc (map contents args))
         (let ((raised (raise-args (highest-type type-tags) args '())))
           (if raised
               (let* ((type-tags-raised (map type-tag raised))
                      (alternate-proc (get op type-tags-raised)))
                 (if alternate-proc
                     (apply alternate-proc (map contents raised))
                     (error "No suitable method found -- APPLY-GENERIC" (list op type-tags))))
               (error "No suitable coercions found -- APPLY-GENERIC"))))))
  (let ((result (search-and-apply-op)))
    (if (in-tower? result)
        (drop result)
        result)))

(define (in-tower? x)
  (and (pair? x) (memq (type-tag x) coercion-tower)))
(define (is-lower? value type)
  (let ((type-and-higher (memq type coercion-tower)))
    (if (and type-and-higher (in-tower? value))
        (not (memq (type-tag value) type-and-higher))
        (error "Reference type or provided value not in tower -- IS-LOWER?" (list type value)))))
(define (attach-tag type-tag contents) 
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum) 
      (car datum)
      (error "Bad tagged datum -- TYPE-TAG" (datum))))
(define (contents datum)
  (if (pair? datum) 
      (cdr datum)
      (error "Bad tagged datum -- CONTENTS" (datum))))

;;complex numbers - polar and rectangular packages
(define (install-rectangular-package)
  ;;internal procedures
  (define (r-part z) (car z))
  (define (i-part z) (cdr z))
  (define (make-from-real-imag x y)
    (if (and (is-lower? x 'complex) (is-lower? y 'complex))
        (cons (drop x) (drop y))
        (error "Got non-tagged real/imaginary parts -- RECTANGULAR PACKAGE" (list x y))))
  (define (magnitude z) 
    (square-root (add (square (r-part z))
                      (square (i-part z)))))
  (define (angle z) (arctan (i-part z)
                            (r-part z)))
  (define (make-from-mag-ang r a)
    (if (and (is-lower? r 'complex) (is-lower? a 'complex))
        (cons (mul r (cosine a)) (mul r (sine a)))
        (error "Got non-tagged magnitude/angle -- RECTANGULAR PACKAGE" (list r a))))
  ;;external interfaces
  (define (tag x) (attach-tag 'rectangular x))
  (put 'r-part '(rectangular) r-part)
  (put 'i-part '(rectangular) i-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'equ? '(rectangular rectangular)
       (lambda (x y) (and (equ? (r-part x) (r-part y))
                          (equ? (i-part x) (i-part y)))))
  (put '=zero? '(rectangular rectangular)
       (lambda (x y) (and (=zero? (r-part x))
                          (=zero? (i-part x)))))
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;;internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a)
    (if (and (is-lower? r 'complex) (is-lower? a 'complex))
        (cons (drop r) (drop a))
        (error "Got non-tagged magnitude/angle -- POLAR PACKAGE" (list r a))))
  (define (r-part z)
    (mul (magnitude z) (cosine (angle z))))
  (define (i-part z)
    (mul (magnitude z) (sine (angle z))))
  (define (make-from-real-imag x y)
    (if (and (is-lower? x 'complex) (is-lower? y 'complex))
        (cons (square-root (add (square x) (square y)))
              (arctan y x))
        (error "Got non-tagged real/imaginary parts -- POLAR PACKAGE" (list x y))))
  ;;external interfaces
  (define (tag x) (attach-tag 'polar x))
  (put 'r-part '(polar) r-part)
  (put 'i-part '(polar) i-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'equ? '(polar polar)
       (lambda (x y) (and (equ? (magnitude x) (magnitude y))
                          (equ? (angle x) (angle y)))))
  (put '=zero? '(polar) (lambda (x) (=zero? (magnitude x))))
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(install-rectangular-package)
(install-polar-package)
(define (r-part z) (apply-generic 'r-part z))
(define (i-part z) (apply-generic 'i-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))

;;Generic arithmetics package
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (greater? x y) (apply-generic 'greater? x y))
(define (lesser? x y) (apply-generic 'lesser? x y))
(define (equ? x y) (apply-generic 'equ? x y))
(define (=zero? x) (apply-generic '=zero? x))
(define (square x) (apply-generic 'mul x x))
(define (square-root x) (apply-generic 'square-root x))
(define (arctan x) (apply-generic 'arctan x))
(define (sine x) (apply-generic 'sine x))
(define (cosine x) (apply-generic 'cosine x))

(define (install-integer-package)
  (define (tag x) (attach-tag 'integer x))
  (define (int2rat x) (make-rational x 1))
  (put 'make 'integer (lambda (x) (tag x)))
  (put 'add '(integer integer) (lambda (x y) (tag (+ x y))))
  (put 'sub '(integer integer) (lambda (x y) (tag (- x y))))
  (put 'mul '(integer integer) (lambda (x y) (tag (* x y))))
  (put 'div '(integer integer) (lambda (x y) (tag (/ x y))))
  (put 'equ? '(integer integer) (lambda (x y) (= x y)))
  (put 'lesser? '(integer integer) (lambda (x y) (< x y)))
  (put 'greater? '(integer integer) (lambda (x y) (> x y)))
  (put '=zero? '(integer) (lambda (x) (= x 0)))
  (put 'square-root '(integer) (lambda (x) (square-root (make-real x))))
  (put 'arctan '(integer integer) (lambda (x y) (arctan (make-real x) (make-real y))))
  (put 'sine '(integer) (lambda (x) (sine (make-real x))))
  (put 'cosine '(integer) (lambda (x) (cosine (make-real x))))
  (put 'addd '(integer integer integer) (lambda (x y z) (tag (+ x y z))))
  (put-coercion 'integer 'rational int2rat)
  'done)
(define (make-integer n)
  (if (integer? n)
      ((get 'make 'integer) n)
      (error "Got non-integer -- MAKE-INTEGER" n)))

(define (install-real-package)
  (define (tag x) (attach-tag 'real x))
  (define (sqrt-real x)
    (let ((root (sqrt x)))
      (make-from-real-imag (tag (real-part root))
                           (tag (imag-part root)))))
  (define (real2complex x) (make-from-real-imag (tag x) (tag 0)))
  (define (real2rat x) 
    (make-rational (inexact->exact (numerator x))
                   (inexact->exact (denominator x))))
  (put 'add '(real real) (lambda (x y) (tag (+ x y))))
  (put 'sub '(real real) (lambda (x y) (tag (- x y))))
  (put 'mul '(real real) (lambda (x y) (tag (* x y))))
  (put 'div '(real real) (lambda (x y) (tag (/ x y))))
  (put 'equ? '(real real) (lambda (x y) (= x y)))
  (put '=zero? '(real) (lambda (x) (= x 0)))
  (put 'square-root '(real) (lambda (x) (sqrt-real x)))
  (put 'arctan '(real real) (lambda (x y) (tag (atan x y))))
  (put 'sine '(real) (lambda (x) (tag (sin x))))
  (put 'cosine '(real) (lambda (x) (tag (cos x))))
  (put 'addd '(real real real) (lambda (x y z) (tag (+ x y z))))
  (put-coercion 'real 'complex real2complex)
  (put-coercion 'real 'rational real2rat)
  (put 'make 'real (lambda (x) (tag x)))
  'done)
(define (make-real x)
  ((get 'make 'real) x))

(define (install-rational-package)
  ;;internal functions
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (if (and (integer? n) (integer? d))
        (let ((g (gcd n d)))
          (cons (/ n g) (/ d g)))
        (error "Got non-integer numerator/denominator -- RATIONAL PACKAGE" (list n d))))
  (define (add x y)
    (make-rat (+ (* (numer x) (denom y)) 
                 (* (denom x) (numer y)))
              (* (denom x) (denom y))))
  (define (sub x y)
    (make-rat (- (* (numer x) (denom y)) 
                 (* (denom x) (numer y)))
              (* (denom x) (denom y))))
  (define (mul x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (rat2real x)
    (make-real (/ (numer x) (denom x))))
  (define (rat2int x) (make-integer (round (/ (numer x) (denom x)))))
  (put 'square-root '(rational) (lambda (x) (square-root (rat2real x))))
  (put 'arctan '(rational rational) (lambda (x y) (arctan (rat2real x) (rat2real y))))
  (put 'sine '(rational) (lambda (x) (sine (rat2real x))))
  (put 'cosine '(rational) (lambda (x) (cosine (rat2real x))))
  ;;external interfaces
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div x y))))
  (put 'equ? '(rational rational)
       (lambda (x y) (and (= (numer x) (numer y))
                          (= (denom x) (denom y)))))
  (put '=zero? '(rational) (lambda (x) (= (numer x) 0)))
  (put-coercion 'rational 'real rat2real)
  (put-coercion 'rational 'integer rat2int)
  (put 'numer '(rational) numer)
  (put 'denom '(rational) denom)
  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
(define (numer r) (apply-generic 'numer r))
(define (denom r) (apply-generic 'denom r))

(define (install-complex-package)
  ;;inherited functions from rectangular and polar
  (define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;;internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (add (r-part z1) (r-part z2))
                         (add (i-part z1) (i-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (r-part z1) (r-part z2))
                         (sub (i-part z1) (i-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
                       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
                       (sub (angle z1) (angle z2))))
  (define (addd-complex z1 z2 z3)
    (make-from-real-imag (addd (r-part z1)
                               (r-part z2)
                               (r-part z3))
                         (addd (i-part z1)
                               (i-part z2)
                               (i-part z3))))
  (define (complex2real x)
    (let* ((r (r-part x))
           (type (type-tag r)))
      (cond ((eq? type 'real) r)
            ((is-lower? r 'real) (raise-loop r 'real))
            (else (error "Unable to drop complex to real -- COMPLEX2REAL" x)))))
  (define (complex2poly x)
    (make-from-dense-termlist 'unbound (list (drop (tag x)))))
  ;;external interfaces
  (define (tag x) (attach-tag 'complex x))
  (put-coercion 'complex 'real complex2real)
  (put-coercion 'complex 'polynomial complex2poly)
  (put 'add '(complex complex)
       (lambda (x y) (tag (add-complex x y))))
  (put 'mul '(complex complex)
       (lambda (x y) (tag (mul-complex x y))))
  (put 'sub '(complex complex)
       (lambda (x y) (tag (sub-complex x y))))
  (put 'div '(complex complex)
       (lambda (x y) (tag (div-complex x y))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'addd '(complex complex complex)
       (lambda (z1 z2 z3) (tag (addd-complex z1 z2 z3))))
  ;;these dispatch to the same procedure but the apply-generic
  ;;takes care of stripping away the type-tag at each level.
  (put 'r-part '(complex) r-part)
  (put 'i-part '(complex) i-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'equ? '(complex complex) equ?)
  (put '=zero? '(complex) =zero?)
  'done)
(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

;;coercion tower
(define coercion-tower '(integer rational real complex polynomial dense-termlist sparse-termlist))

(define (raise-rec x types)
  (cond ((null? types) (error "Type not found in type tower -- RAISE-REC" (list x coercion-tower)))
        ((eq? (type-tag x) (car types))
         (if (null? (cdr types))
             x
             (let ((raiser (get-coercion (type-tag x) (cadr types))))
               (if raiser
                   (raiser (contents x))
                   x))))
        (else (raise-rec x (cdr types)))))

(define (raise x)
  (raise-rec x coercion-tower))

(define (project x)
  (raise-rec x (reverse coercion-tower)))

(define (filter predicate sequence)
  (cond ((null? sequence) '())
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

(define (highest-type type-list)
  (define (filter-lowest-type remaining-tower remaining-types)
    (if (null? remaining-tower)
        (error "Some types were not in the tower -- HIGHEST-TYPE" (list type-list coercion-tower))
        (let* ((predicate (lambda (x) (not (eq? x (car remaining-tower)))))
               (filtered-types (filter predicate remaining-types)))
          (if (null? filtered-types)
              (car remaining-tower)
              (filter-lowest-type (cdr remaining-tower) filtered-types)))))
  (if (null? type-list)
      #f
      (filter-lowest-type coercion-tower type-list)))


(define (install-sparse-term-package)
  ;; internal procedures
  (define (build-from-paired-termlist terms result)
    (if (null? terms)
        result
        (build-from-paired-termlist (cdr terms)
                                    (insert-term (car terms) result))))
  (define (build-from-dense-termlist terms term-order)
    (cond ((null? terms) '())
          ((=zero? (car terms)) (build-from-dense-termlist (cdr terms)
                                                           (sub term-order (make-integer 1))))
          (else (cons (make-term term-order (car terms))
                      (build-from-dense-termlist (cdr terms)
                                                 (sub term-order (make-integer 1)))))))
  (define (insert-term term terms)
    (if (empty-termlist? terms)
        (adjoin-term term (the-empty-termlist))
        (let* ((highest-term (first-term terms))
               (highest-order (order highest-term))
               (this-order (order term)))
          (cond ((greater? highest-order this-order)
                 (adjoin-term highest-term (insert-term term (rest-terms terms))))
                ((lesser? highest-order this-order)
                 (adjoin-term term terms))
                (else (adjoin-term (make-term this-order (add (coeff term) (coeff highest-term)))
                                   (rest-terms terms)))))))
  ;; representation of terms and term lists
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))
  (define (negate-terms L)
    (mul-terms L (list (make-term (make-integer 0)
                                  (make-integer -1)))))
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((greater? (order t1) (order t2))
                    (adjoin-term t1 (add-terms (rest-terms L1) L2)))
                   ((lesser? (order t1) (order t2))
                    (adjoin-term t2 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term (make-term (order t1)
                                            (add (coeff t1) (coeff t2)))
                                 (add-terms (rest-terms L1) (rest-terms L2)))))))))
  (define (sub-terms L1 L2)
    (add-terms L1 (negate-terms L2)))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term (make-term (add (order t1) (order t2))
                                  (mul (coeff t1) (coeff t2)))
                       (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (=zero-all-terms? L)
    (cond ((empty-termlist? L) #t)
          ((not (=zero? (coeff (first-term L)))) #f)
          (else (=zero-all-terms? (rest-terms L)))))
  (define (constant-term L)
    (cond ((empty-termlist? L) (make-integer 0))
          ((=zero? (order (first-term L))) (coeff (first-term L)))
          (else (constant-term (rest-terms L)))))
  ;; coercion
  (define (count-zero-coeffs L result)
    (if (or (empty-termlist? L) (empty-termlist? (rest-terms L)))
        result
        (let ((term-order (order (first-term L)))
              (next-order (order (first-term (rest-terms L)))))
          (count-zero-coeffs (rest-terms L)
                             (add result
                                  (sub term-order next-order))))))
  (define (keep-as-sparse? L)
    (if (empty-termlist? L)
        #f
        (let ((list-order (order (first-term L)))
              (num-zeros (count-zero-coeffs L (make-integer 0))))
          (store-as-sparse? list-order num-zeros))))
  (define (sparse2dense L)
    (if (keep-as-sparse? L)
        (tag L)
        ((get 'make-from-sparse-termlist 'dense-termlist) L)))
  ;; interface to rest of the system
  (define (tag L) (attach-tag 'sparse-termlist L))
  (put-coercion 'sparse-list 'dense-list sparse2dense)
  (put 'add '(sparse-termlist sparse-termlist) 
       (lambda (L1 L2) (tag (add-terms L1 L2))))
  (put 'sub '(sparse-termlist sparse-termlist) 
       (lambda (L1 L2) (tag (sub-terms L1 L2))))
  (put 'mul '(sparse-termlist sparse-termlist) 
       (lambda (L1 L2) (tag (mul-terms L1 L2))))
  (put 'negate-terms '(sparse-termlist) 
       (lambda (L) (tag (negate-terms L))))
  (put '=zero? '(sparse-termlist) (lambda (L) (=zero-all-terms? L)))
  (put 'constant-term '(sparse-termlist) (lambda (L) (constant-term L)))
  (put 'make-from-sparse-termlist 'sparse-termlist
       (lambda (terms) (tag (build-from-paired-termlist terms (the-empty-termlist)))))
  (put 'make-from-dense-termlist 'sparse-termlist
       (lambda (terms) (tag (build-from-dense-termlist terms (make-integer (length terms))))))
  'done)

(define (store-as-sparse? num-terms num-zero-terms)
  (lesser? (div num-terms num-zero-terms) (make-integer 5)))

(define (install-dense-term-package)
  ;; internal procedures
  (define (order term-list)
    (make-integer (- (length term-list) 1)))
  (define (the-empty-termlist) '())
  (define (empty-termlist? term-list) (null? term-list))
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (adjoin-term term term-list)
    (cons term term-list))
  (define (build-from-paired-termlist terms result)
    (if (null? terms)
        result
        (let* ((term (car terms))
               (term-order (car term))
               (term-coeff (cadr term)))
          (build-from-paired-termlist (cdr terms)
                                      (insert-term term-coeff term-order result)))))
  (define (insert-term term-coeff term-order terms)
    (if (empty-termlist? terms)
        (if (=zero? term-order)
            (list term-coeff)
            (adjoin-term term-coeff
                         (insert-term (make-integer 0)
                                      (sub term-order (make-integer 1))
                                      terms)))
        (let ((existing-order (order terms)))
          (cond ((greater? existing-order term-order)
                 (adjoin-term (car terms) (insert-term term-coeff term-order (cdr terms))))
                ((lesser? existing-order term-order)
                 (adjoin-term term-coeff (insert-term (make-integer 0)
                                                      (sub term-order (make-integer 1))
                                                      terms)))
                (else (adjoin-term (add term-coeff (car terms)) (cdr terms)))))))
  ;; arithmetic ops
  (define (negate-terms L)
    (mul-terms L (list (make-integer -1)) (order L) (make-integer 0)))
  (define (add-terms L1 L2 order1 order2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((greater? order1 order2)
                    (adjoin-term t1 (add-terms (rest-terms L1)
                                               L2
                                               (sub order1 (make-integer 1))
                                               order2)))
                   ((lesser? order1 order2)
                    (adjoin-term t2 (add-terms L1
                                               (rest-terms L2)
                                               order1
                                               (sub order2 (make-integer 1)))))
                   (else
                    (adjoin-term (add t1 t2)
                                 (add-terms (rest-terms L1)
                                            (rest-terms L2)
                                            (sub order1 (make-integer 1))
                                            (sub order2 (make-integer 1))))))))))
  (define (sub-terms L1 L2)
    (add-terms L1 (negate-terms L2) (order L1) (order L2)))
  (define (mul-terms L1 L2 order1 order2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (append (mul-term-by-all-terms (first-term L1) L2) (zero-term-list order1))
                   (mul-terms (rest-terms L1) L2 (sub order1 (make-integer 1)) order2)
                   (add order1 order2)
                   (add (sub order1 (make-integer 1)) order2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term (mul t1 t2)
                       (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (zero-term-list n)
    (if (=zero? n)
        (the-empty-termlist)
        (adjoin-term (make-integer 0)
                     (zero-term-list (sub n (make-integer 1))))))
  (define (=zero-all-terms? L)
    (cond ((empty-termlist? L) #t)
          ((not (=zero? (first-term L))) #f)
          (else (=zero-all-terms? (rest-terms L)))))
  (define (constant-term L)
    (cond ((empty-termlist? L) (make-integer 0))
          ((=zero? (order L)) (first-term L))
          (else (constant-term (rest-terms L)))))
  (define (dense2sparse L)
    ((get 'make-from-dense-termlist 'sparse-termlist) L))
  ;; interface to rest of the system
  (define (tag L) (attach-tag 'dense-termlist L))
  (put-coercion 'dense-termlist 'sparse-termlist dense2sparse)
  (put 'add '(dense-termlist dense-termlist) 
       (lambda (L1 L2) (tag (add-terms L1 L2 (order L1) (order L2)))))
  (put 'sub '(dense-termlist dense-termlist) 
       (lambda (L1 L2) (tag (sub-terms L1 L2))))
  (put 'mul '(dense-termlist dense-termlist) 
       (lambda (L1 L2) (tag (mul-terms L1 L2 (order L1) (order L2)))))
  (put 'negate-terms '(dense-termlist) 
       (lambda (L) (tag (negate-terms L))))
  (put '=zero? '(dense-termlist) (lambda (L) (=zero-all-terms? L)))
  (put 'constant-term '(dense-termlist) (lambda (L) (constant-term L)))
  (put 'make-from-sparse-termlist 'dense-termlist
       (lambda (terms) (tag (build-from-paired-termlist terms (the-empty-termlist)))))
  (put 'make-from-dense-termlist 'dense-termlist
       (lambda (terms) (tag terms)))
  'done)

(install-sparse-term-package)
(install-dense-term-package)
(define (constant-term x) (apply-generic 'constant-term x))

;;Polynomial library
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly var termlist)
    (cons var termlist))
  (define (make-from-sparse-termlist var terms)
    (make-poly var ((get 'make-from-sparse-termlist 'sparse-termlist) terms)))
  (define (make-from-dense-termlist var terms)
    (make-poly var ((get 'make-from-dense-termlist 'dense-termlist) terms)))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  (define (variable? x) (symbol? x))
  (define (same-variable? x1 x2)
    (and (variable? x1) (variable? x2)
         (or (eq? x1 x2)
             (eq? x1 'unbound)
             (eq? x2 'unbound))))
  (define (select-variable p1 p2)
    (let ((v1 (variable p1))
          (v2 (variable p2)))
      (if (eq? v1 'unbound) v2 v1)))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (select-variable p1 p2)
                   (add (term-list p1)
                        (term-list p2)))
        (error "Polynomials do not correspond to the same variable -- ADD-POLY" (list p1 p2))))
  (define (sub-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (select-variable p1 p2)
                   (sub (term-list p1)
                        (term-list p2)))
        (error "Polynomials do not correspond to the same variable -- SUB-POLY" (list p1 p2))))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (select-variable p1 p2)
                   (mul (term-list p1)
                        (term-list p2)))
        (error "Polynomials do not correspond to the same variable -- MUL-POLY" (list p1 p2))))
  (define (poly2complex p)
    (let ((constant (constant-term (term-list p))))
      (display "DEBUG -- POLY2COMPLEX") (newline)
      (display constant) (newline)
      (if (is-lower? constant 'complex)
          (raise-loop constant 'complex)
          constant)))
  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put-coercion 'polynomial 'complex poly2complex)
  (put 'add '(polynomial polynomial) 
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'sub '(polynomial polynomial) 
       (lambda (p1 p2) (tag (sub-poly p1 p2))))
  (put 'mul '(polynomial polynomial) 
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put '=zero? '(polynomial) (lambda (x) (=zero? (term-list x))))
  (put 'equ? '(polynomial polynomial)
       (lambda (p1 p2) (=zero? (term-list (sub-poly p1 p2)))))
  (put 'make-from-sparse-termlist 'polynomial
       (lambda (var terms) (tag (make-from-sparse-termlist var terms))))
  (put 'make-from-dense-termlist 'polynomial
       (lambda (var terms) (tag (make-from-dense-termlist var terms))))
  'done)
(define (make-from-sparse-termlist var terms)
  ((get 'make-from-sparse-termlist 'polynomial) var terms))
(define (make-from-dense-termlist var terms)
  ((get 'make-from-dense-termlist 'polynomial) var terms))


;;testing it all out
(install-integer-package)
(install-real-package)
(install-rational-package)
(install-complex-package)
(install-polynomial-package)

(newline)
(display (make-rational 1 2)) (newline)
(display (make-from-real-imag (make-integer 1) (make-integer 2))) (newline)(newline)

(define z1 (make-from-real-imag (make-integer 3) (make-integer 4)))
(define z2 (make-from-real-imag (make-integer 3) (make-integer 4)))
(display (magnitude z1)) (newline)(newline)

(display (add (make-integer 3) (make-integer 4))) (newline)
(display (add (make-real 3) (make-real 4))) (newline)
(newline)(newline)(display "BREAKPOINT")(newline)(newline)
(display (add z1 z1)) (newline)(newline)

(display (equ? z1 z2)) (newline)
(display (equ? (make-integer 1) (make-integer 1))) (newline)
(display (equ? (make-integer 1) (make-integer 2))) (newline)(newline)

(display (=zero? (sub (make-integer 1) (make-integer 1)))) (newline)
(display (=zero? (make-from-mag-ang (make-real 0) (make-real 5)))) (newline)
(display (=zero? (make-rational 1 2))) (newline)(newline)

(display (add z1 (make-real 2))) (newline)
(display (make-from-mag-ang (make-real 0.5) (make-integer 2)))(newline)
(display (add z1 (make-real 0.5))) (newline) (newline)

(define (addd x y z) (apply-generic 'addd x y z))
(display (addd z1 z1 z1)) (newline) (newline)

(display (sub z1 z1)) (newline)
(display (make-real 0.5)) (newline)(newline)

(display (square-root (make-real 4)))(newline)
(display (square-root (make-integer -1)))(newline)(newline)

(define p1 (make-from-sparse-termlist 'x (list (list (make-integer 2) (make-real 3))
                                               (list (make-integer 0) (make-real 2.5)))))
(define p2 (make-from-sparse-termlist 'x (list (list (make-integer 1) (make-real 3.5))
                                               (list (make-integer 0) (make-real 4.5)))))
(define p3 (make-from-sparse-termlist 'x (list (list (make-integer 0) (make-real 0.0))
                                               (list (make-integer 3) (make-real 4.5)))))
(display p3) (newline)
(display (add p1 p2)) (newline)
(display (sub p1 p2)) (newline)
(display (mul p1 p2)) (newline) (newline)

(display (=zero? (make-from-sparse-termlist 'x '()))) (newline)
(display (=zero? (make-from-sparse-termlist 'x (list (list (make-integer 3) (make-real 0))
                                                     (list (make-integer 2) (make-rational 0 4))
                                                     (list (make-integer 1) (make-integer 0)))))) (newline)
(display (=zero? (make-from-sparse-termlist 'x (list (list (make-integer 3) (make-real 0))
                                                     (list (make-integer 2) (make-rational 4 4))
                                                     (list (make-integer 1) (make-integer 0)))))) (newline) (newline)



(define p4 (make-from-dense-termlist 'x (list (make-real 3) (make-integer 0) (make-real 2.5))))
(define p5 (make-from-dense-termlist 'x (list (make-real 3.5) (make-real 4.5))))
(define p6 (make-from-dense-termlist 'x (list (make-real 4.5) (make-integer 0) (make-integer 0) (make-real 0.0))))
(display p6) (newline)
(display (add p4 p5)) (newline)
(display (sub p4 p5)) (newline)
(display (mul p5 p4)) (newline) (newline)

