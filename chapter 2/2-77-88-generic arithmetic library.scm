#lang sicp
;;Table operations
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  #f))
            #f)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation - TABLE" m))))
    dispatch))
(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))
(define (put-coercion source-type target-type proc)
  (put 'coercion (list source-type target-type) proc))
(define (get-coercion source-type target-type)
  (get 'coercion (list source-type target-type)))


;;helper functions
(define (raise-loop arg target-type)
  (let ((raised (raise arg)))
    (if (eq? (type-tag raised) target-type)
        raised
        (raise-loop raised target-type))))

(define (drop arg)
  (let* ((og-type (type-tag arg))
         (dropped (project arg))
         (drop-type (type-tag dropped))
         (re-raised (raise dropped)))
    (if (and (not (eq? og-type drop-type)) (equ? re-raised arg))
         (drop dropped)
        arg)))


(define (raise-args target-type remaining-args result)
  (if (null? remaining-args)
      result
      (let* ((arg (car remaining-args))
             (type (type-tag arg)))
        (if (eq? type target-type)
            (raise-args target-type
                        (cdr remaining-args)
                        (append result (list arg)))
            (raise-args target-type
                        (cdr remaining-args)
                        (append result (list (raise-loop arg target-type))))))))

(define (apply-generic op . args)
  (define (search-and-apply-op)
    (let* ((type-tags (map type-tag args))
           (proc (get op type-tags)))
     (if proc
         (apply proc (map contents args))
         (let ((raised (raise-args (highest-type type-tags) args '())))
           (if raised
               (let* ((type-tags-raised (map type-tag raised))
                      (alternate-proc (get op type-tags-raised)))
                 (if alternate-proc
                     (apply alternate-proc (map contents raised))
                     (error "No suitable method found -- APPLY-GENERIC" (list op type-tags))))
               (error "No suitable coercions found -- APPLY-GENERIC"))))))
  (let ((result (search-and-apply-op)))
    (if (in-tower? result)
        (drop result)
        result)))

(define (in-tower? x)
  (and (pair? x) (memq (type-tag x) coercion-tower)))
(define (is-lower? value type)
  (let ((type-and-higher (memq type coercion-tower)))
    (if (and type-and-higher (in-tower? value))
        (not (memq (type-tag value) type-and-higher))
        (error "Reference type or provided value not in tower -- IS-LOWER?" (list type value)))))
(define (attach-tag type-tag contents) 
  (cons type-tag contents))
(define (type-tag datum)
  (if (pair? datum) 
      (car datum)
      (error "Bad tagged datum -- TYPE-TAG" (datum))))
(define (contents datum)
  (if (pair? datum) 
      (cdr datum)
      (error "Bad tagged datum -- CONTENTS" (datum))))

;;complex numbers - polar and rectangular packages
(define (install-rectangular-package)
  ;;internal procedures
  (define (r-part z) (car z))
  (define (i-part z) (cdr z))
  (define (make-from-real-imag x y)
    (if (and (is-lower? x 'complex) (is-lower? y 'complex))
        (cons (drop x) (drop y))
        (error "Got non-tagged real/imaginary parts -- RECTANGULAR PACKAGE" (list x y))))
  (define (magnitude z) 
    (square-root (add (square (r-part z))
                      (square (i-part z)))))
  (define (angle z) (arctan (i-part z)
                            (r-part z)))
  (define (make-from-mag-ang r a)
    (if (and (is-lower? r 'complex) (is-lower? a 'complex))
        (cons (mul r (cosine a)) (mul r (sine a)))
        (error "Got non-tagged magnitude/angle -- RECTANGULAR PACKAGE" (list r a))))
  ;;external interfaces
  (define (tag x) (attach-tag 'rectangular x))
  (put 'r-part '(rectangular) r-part)
  (put 'i-part '(rectangular) i-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'equ? '(rectangular rectangular)
       (lambda (x y) (and (equ? (r-part x) (r-part y))
                          (equ? (i-part x) (i-part y)))))
  (put '=zero? '(rectangular rectangular)
       (lambda (x y) (and (=zero? (r-part x))
                          (=zero? (i-part x)))))
  (put 'make-from-real-imag 'rectangular
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(define (install-polar-package)
  ;;internal procedures
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a)
    (if (and (is-lower? r 'complex) (is-lower? a 'complex))
        (cons (drop r) (drop a))
        (error "Got non-tagged magnitude/angle -- POLAR PACKAGE" (list r a))))
  (define (r-part z)
    (mul (magnitude z) (cosine (angle z))))
  (define (i-part z)
    (mul (magnitude z) (sine (angle z))))
  (define (make-from-real-imag x y)
    (if (and (is-lower? x 'complex) (is-lower? y 'complex))
        (cons (square-root (add (square x) (square y)))
              (arctan y x))
        (error "Got non-tagged real/imaginary parts -- POLAR PACKAGE" (list x y))))
  ;;external interfaces
  (define (tag x) (attach-tag 'polar x))
  (put 'r-part '(polar) r-part)
  (put 'i-part '(polar) i-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'equ? '(polar polar)
       (lambda (x y) (and (equ? (magnitude x) (magnitude y))
                          (equ? (angle x) (angle y)))))
  (put '=zero? '(polar) (lambda (x) (=zero? (magnitude x))))
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)

(install-rectangular-package)
(install-polar-package)
(define (r-part z) (apply-generic 'r-part z))
(define (i-part z) (apply-generic 'i-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))

;;Generic arithmetics package
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (greater? x y) (apply-generic 'greater? x y))
(define (lesser? x y) (apply-generic 'lesser? x y))
(define (equ? x y) (apply-generic 'equ? x y))
(define (=zero? x) (apply-generic '=zero? x))
(define (square x) (apply-generic 'mul x x))
(define (square-root x) (apply-generic 'square-root x))
(define (arctan x) (apply-generic 'arctan x))
(define (sine x) (apply-generic 'sine x))
(define (cosine x) (apply-generic 'cosine x))

(define (install-integer-package)
  (define (tag x) (attach-tag 'integer x))
  (define (int2rat x) (make-rational x 1))
  (put 'make 'integer (lambda (x) (tag x)))
  (put 'add '(integer integer) (lambda (x y) (tag (+ x y))))
  (put 'sub '(integer integer) (lambda (x y) (tag (- x y))))
  (put 'mul '(integer integer) (lambda (x y) (tag (* x y))))
  (put 'div '(integer integer) (lambda (x y) (tag (/ x y))))
  (put 'equ? '(integer integer) (lambda (x y) (= x y)))
  (put 'lesser? '(integer integer) (lambda (x y) (< x y)))
  (put 'greater? '(integer integer) (lambda (x y) (> x y)))
  (put '=zero? '(integer) (lambda (x) (= x 0)))
  (put 'square-root '(integer) (lambda (x) (square-root (make-real x))))
  (put 'arctan '(integer integer) (lambda (x y) (arctan (make-real x) (make-real y))))
  (put 'sine '(integer) (lambda (x) (sine (make-real x))))
  (put 'cosine '(integer) (lambda (x) (cosine (make-real x))))
  (put 'addd '(integer integer integer) (lambda (x y z) (tag (+ x y z))))
  (put-coercion 'integer 'rational int2rat)
  'done)
(define (make-integer n)
  (if (integer? n)
      ((get 'make 'integer) n)
      (error "Got non-integer -- MAKE-INTEGER" n)))

(define (install-real-package)
  (define (tag x) (attach-tag 'real x))
  (define (sqrt-real x)
    (let ((root (sqrt x)))
      (make-from-real-imag (tag (real-part root))
                           (tag (imag-part root)))))
  (define (real2complex x) (make-from-real-imag (tag x) (tag 0)))
  (define (real2rat x) 
    (make-rational (inexact->exact (numerator x))
                   (inexact->exact (denominator x))))
  (put 'add '(real real) (lambda (x y) (tag (+ x y))))
  (put 'sub '(real real) (lambda (x y) (tag (- x y))))
  (put 'mul '(real real) (lambda (x y) (tag (* x y))))
  (put 'div '(real real) (lambda (x y) (tag (/ x y))))
  (put 'equ? '(real real) (lambda (x y) (= x y)))
  (put '=zero? '(real) (lambda (x) (= x 0)))
  (put 'square-root '(real) (lambda (x) (sqrt-real x)))
  (put 'arctan '(real real) (lambda (x y) (tag (atan x y))))
  (put 'sine '(real) (lambda (x) (tag (sin x))))
  (put 'cosine '(real) (lambda (x) (tag (cos x))))
  (put 'addd '(real real real) (lambda (x y z) (tag (+ x y z))))
  (put-coercion 'real 'complex real2complex)
  (put-coercion 'real 'rational real2rat)
  (put 'make 'real (lambda (x) (tag x)))
  'done)
(define (make-real x)
  ((get 'make 'real) x))

(define (install-rational-package)
  ;;internal functions
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (if (and (integer? n) (integer? d))
        (let ((g (gcd n d)))
          (cons (/ n g) (/ d g)))
        (error "Got non-integer numerator/denominator -- RATIONAL PACKAGE" (list n d))))
  (define (add x y)
    (make-rat (+ (* (numer x) (denom y)) 
                 (* (denom x) (numer y)))
              (* (denom x) (denom y))))
  (define (sub x y)
    (make-rat (- (* (numer x) (denom y)) 
                 (* (denom x) (numer y)))
              (* (denom x) (denom y))))
  (define (mul x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (rat2real x)
    (make-real (/ (numer x) (denom x))))
  (define (rat2int x) (make-integer (round (/ (numer x) (denom x)))))
  (put 'square-root '(rational) (lambda (x) (square-root (rat2real x))))
  (put 'arctan '(rational rational) (lambda (x y) (arctan (rat2real x) (rat2real y))))
  (put 'sine '(rational) (lambda (x) (sine (rat2real x))))
  (put 'cosine '(rational) (lambda (x) (cosine (rat2real x))))
  ;;external interfaces
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational) (lambda (x y) (tag (add x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div x y))))
  (put 'equ? '(rational rational)
       (lambda (x y) (and (= (numer x) (numer y))
                          (= (denom x) (denom y)))))
  (put '=zero? '(rational) (lambda (x) (= (numer x) 0)))
  (put-coercion 'rational 'real rat2real)
  (put-coercion 'rational 'integer rat2int)
  (put 'numer '(rational) numer)
  (put 'denom '(rational) denom)
  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  'done)
(define (make-rational n d)
  ((get 'make 'rational) n d))
(define (numer r) (apply-generic 'numer r))
(define (denom r) (apply-generic 'denom r))

(define (install-complex-package)
  ;;inherited functions from rectangular and polar
  (define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;;internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (add (r-part z1) (r-part z2))
                         (add (i-part z1) (i-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (r-part z1) (r-part z2))
                         (sub (i-part z1) (i-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
                       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
                       (sub (angle z1) (angle z2))))
  (define (addd-complex z1 z2 z3)
    (make-from-real-imag (addd (r-part z1)
                               (r-part z2)
                               (r-part z3))
                         (addd (i-part z1)
                               (i-part z2)
                               (i-part z3))))
  (define (complex2real x)
    (let* ((r (r-part x))
           (type (type-tag r)))
      (cond ((eq? type 'real) r)
            ((is-lower? r 'real) (raise-loop r 'real))
            (else (error "Unable to drop complex to real -- COMPLEX2REAL" x)))))
  ;;external interfaces
  (define (tag x) (attach-tag 'complex x))
  (put-coercion 'complex 'real complex2real)
  (put 'add '(complex complex)
       (lambda (x y) (tag (add-complex x y))))
  (put 'mul '(complex complex)
       (lambda (x y) (tag (mul-complex x y))))
  (put 'sub '(complex complex)
       (lambda (x y) (tag (sub-complex x y))))
  (put 'div '(complex complex)
       (lambda (x y) (tag (div-complex x y))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'addd '(complex complex complex)
       (lambda (z1 z2 z3) (tag (addd-complex z1 z2 z3))))
  ;;these dispatch to the same procedure but the apply-generic
  ;;takes care of stripping away the type-tag at each level.
  (put 'r-part '(complex) r-part)
  (put 'i-part '(complex) i-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)
  (put 'equ? '(complex complex) equ?)
  (put '=zero? '(complex) =zero?)
  'done)
(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))

;;coercion tower
(define coercion-tower '(integer rational real complex))

(define (raise-rec x types)
  (cond ((null? types) (error "Type not found in type tower -- RAISE" (list x coercion-tower)))
        ((eq? (type-tag x) (car types))
         (if (null? (cdr types))
             x
             (let ((raiser (get-coercion (type-tag x) (cadr types))))
               (if raiser
                   (raiser (contents x))
                   (error "Raising coercion not found for pairs -- RAISE" (list (type-tag x) (cadr types)))))))
        (else (raise-rec x (cdr types)))))

(define (raise x)
  (raise-rec x coercion-tower))

(define (project x)
  (raise-rec x (reverse coercion-tower)))

(define (filter predicate sequence)
  (cond ((null? sequence) '())
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

(define (highest-type type-list)
  (define (filter-lowest-type remaining-tower remaining-types)
    (if (null? remaining-tower)
        (error "Some types were not in the tower -- HIGHEST-TYPE" (list type-list coercion-tower))
        (let* ((predicate (lambda (x) (not (eq? x (car remaining-tower)))))
               (filtered-types (filter predicate remaining-types)))
          (if (null? filtered-types)
              (car remaining-tower)
              (filter-lowest-type (cdr remaining-tower) filtered-types)))))
  (if (null? type-list)
      #f
      (filter-lowest-type coercion-tower type-list)))

;;Polynomial library
(define (install-polynomial-package)
  ;; internal procedures
  ;; representation of poly
  (define (make-poly variable term-list)
    (cons variable (build-term-list term-list (the-empty-termlist))))
  (define (build-term-list terms result)
    (if (null? terms)
        result
        (build-term-list (cdr terms) (insert-term (car terms) result))))
  (define (insert-term term terms)
    (if (empty-termlist? terms)
        (adjoin-term term (the-empty-termlist))
        (let* ((highest-term (first-term terms))
               (highest-order (order highest-term))
               (this-order (order term)))
          (cond ((greater? highest-order this-order)
                 (adjoin-term highest-term (insert-term term (rest-terms terms))))
                ((lesser? highest-order this-order)
                 (adjoin-term term terms))
                (else (adjoin-term (make-term this-order (add (coeff term) (coeff highest-term)))
                                   (rest-terms terms)))))))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  (define (variable? x) (symbol? x))
  (define (same-variable? x1 x2)
    (and (variable? x1) (variable? x2) (eq? x1 x2)))
  (define (check-term-list term-list)
    (if (empty-termlist? term-list)
        #t
        (and (in-tower? (coeff (car term-list)))
             (eq? (type-tag (order (car term-list))) 'integer)
             (check-term-list (rest-terms term-list)))))
  ;; representation of terms and term lists
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term))
        term-list
        (cons term term-list)))
  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))
  (define (negate-terms L)
    (mul-terms L (list (make-term (make-integer 0)
                                  (make-integer -1)))))
  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1))
                 (t2 (first-term L2)))
             (cond ((greater? (order t1) (order t2))
                    (adjoin-term t1 (add-terms (rest-terms L1) L2)))
                   ((lesser? (order t1) (order t2))
                    (adjoin-term t2 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term (make-term (order t1)
                                            (add (coeff t1) (coeff t2)))
                                 (add-terms (rest-terms L1) (rest-terms L2)))))))))
  (define (mul-terms L1 L2)
    (if (empty-termlist? L1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term L1) L2)
                   (mul-terms (rest-terms L1) L2))))
  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term (make-term (add (order t1) (order t2))
                                  (mul (coeff t1) (coeff t2)))
                       (mul-term-by-all-terms t1 (rest-terms L))))))
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (term-list p2)))
        (error "Polynomials do not correspond to the same variable -- ADD-POLY" (list p1 p2))))
  (define (sub-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1)
                              (negate-terms (term-list p2))))
        (error "Polynomials do not correspond to the same variable -- SUB-POLY" (list p1 p2))))
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1)
                              (term-list p2)))
        (error "Polynomials do not correspond to the same variable -- MUL-POLY" (list p1 p2))))
  (define (=zero-all-terms? L)
    (cond ((empty-termlist? L) #t)
          ((not (=zero? (coeff (first-term L)))) #f)
          (else (=zero-all-terms? (rest-terms L)))))
  ;; interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial) 
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'sub '(polynomial polynomial) 
       (lambda (p1 p2) (tag (sub-poly p1 p2))))
  (put 'mul '(polynomial polynomial) 
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put '=zero? '(polynomial) (lambda (x) (=zero-all-terms? (term-list x))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  'done)
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))


;;testing it all out
(install-integer-package)
(install-real-package)
(install-rational-package)
(install-complex-package)
(install-polynomial-package)

(newline)
(display (make-rational 1 2)) (newline)
(display (make-from-real-imag (make-integer 1) (make-integer 2))) (newline)(newline)

(define z1 (make-from-real-imag (make-integer 3) (make-integer 4)))
(define z2 (make-from-real-imag (make-integer 3) (make-integer 4)))
(display (magnitude z1)) (newline)(newline)

(display (add (make-integer 3) (make-integer 4))) (newline)
(display (add (make-real 3) (make-real 4))) (newline)
(newline)(newline)(display "BREAKPOINT")(newline)(newline)
(display (add z1 z1)) (newline)(newline)

(display (equ? z1 z2)) (newline)
(display (equ? (make-integer 1) (make-integer 1))) (newline)
(display (equ? (make-integer 1) (make-integer 2))) (newline)(newline)

(display (=zero? (sub (make-integer 1) (make-integer 1)))) (newline)
(display (=zero? (make-from-mag-ang (make-real 0) (make-real 5)))) (newline)
(display (=zero? (make-rational 1 2))) (newline)(newline)

(display (add z1 (make-real 2))) (newline)
(display (make-from-mag-ang (make-real 0.5) (make-integer 2)))(newline)
(display (add z1 (make-real 0.5))) (newline) (newline)

(define (addd x y z) (apply-generic 'addd x y z))
(display (addd z1 z1 z1)) (newline) (newline)

(display (sub z1 z1)) (newline)
(display (make-real 0.5)) (newline)(newline)

(display (square-root (make-real 4)))(newline)
(display (square-root (make-integer -1)))(newline)(newline)

(define p1 (make-polynomial 'x (list (list (make-integer 2) (make-real 3))
                                     (list (make-integer 0) (make-real 2.5)))))
(define p2 (make-polynomial 'x (list (list (make-integer 1) (make-real 3.5))
                                     (list (make-integer 0) (make-real 4.5)))))
(define p3 (make-polynomial 'x (list (list (make-integer 0) (make-real 0.0))
                                     (list (make-integer 3) (make-real 4.5)))))
(display p3) (newline)
(display (add p1 p2)) (newline)
(display (sub p1 p2)) (newline)
(display (mul p1 p2)) (newline) (newline)

(display (=zero? (make-polynomial 'x '()))) (newline)
(display (=zero? (make-polynomial 'x (list (list (make-integer 3) (make-real 0))
                                           (list (make-integer 2) (make-rational 0 4))
                                           (list (make-integer 1) (make-integer 0)))))) (newline)
(display (=zero? (make-polynomial 'x (list (list (make-integer 3) (make-real 0))
                                           (list (make-integer 2) (make-rational 4 4))
                                           (list (make-integer 1) (make-integer 0)))))) (newline) (newline)



